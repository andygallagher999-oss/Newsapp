<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Global Lens</title>
<style>
  body { font-family: Arial,sans-serif; margin:0; background:#f5f5f5; }
  header { background:#222; color:#fff; padding:10px; text-align:center; font-size:1.4em; }
  #categoryTabs { display:flex; overflow-x:auto; background:#333; }
  #categoryTabs button {
    flex:1; padding:10px; border:none; background:#333; color:#fff; font-size:1em;
    cursor:pointer; white-space:nowrap; outline:none;
  }
  #categoryTabs button.active { background:#555; }
  #content { padding:10px; max-width:900px; margin:auto; }
  .card {
    display:flex; background:#fff; margin-bottom:10px;
    border-radius:6px; overflow:hidden; box-shadow:0 2px 4px rgba(0,0,0,.1);
  }
  .card img {
    width:100px; height:100px; object-fit:cover; flex-shrink:0;
  }
  .info { padding:10px; flex:1; display:flex; flex-direction:column; }
  .title {
    font-weight:bold; margin-bottom:5px; cursor:pointer;
    display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden;
  }
  .summary {
    display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden;
    margin-bottom:5px; font-size:0.9em; color:#333;
  }
  .source { color:#666; font-size:0.85em; }
  .date { color:#999; font-size:0.8em; margin-bottom:6px; }
  #loadingSpinner { text-align:center; padding:15px; display:none; color:#555; }
  #backToTop {
    position: fixed;
    bottom: 30px;
    right: 30px;
    z-index: 999;
    display: none;
    background: #333;
    color: #fff;
    border: none;
    padding: 13px;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(50,50,50,0.15);
    opacity: 0;
    transition: opacity 0.3s;
  }
  #backToTop.show {
    display: block;
    opacity: 1;
  }
  #backToTop:hover {
    background: #555;
  }
</style>
</head>
<body>
<header>Global Lens</header>

<div id="categoryTabs"></div>
<div id="content"></div>
<div id="loadingSpinner">Loading…</div>
<button id="backToTop" title="Back to top">↑</button>

<script>
const API_KEY = "mfvxyevwnjlcnuwmiyprrivbbpyylyhwwzuezdaq";
const BATCH_SIZE = 8;
const PLACEHOLDER = "logo.png";

const categories = {
  Sports:[
    "https://www.sportsnet.ca/feed/",
    "http://feeds.bbci.co.uk/sport/rss.xml",
    "https://www.espn.com/espn/rss/news"
  ],
  Business:[
    "https://www.reuters.com/business/rss",
    "https://www.marketwatch.com/rss/topstories",
    "https://www.investing.com/rss/news.rss"
  ],
  News:[
    "https://www.cbc.ca/cmlink/rss-topstories",
    "https://globalnews.ca/feed/",
    "https://www.ctvnews.ca/rss/ctvnews-ca-top-stories-public-rss-1.822009"
  ],
  Entertainment:[
    "https://globalnews.ca/entertainment/feed/",
    "https://www.ctvnews.ca/entertainment/rss/ctvnews-ca-entertainment-public-rss-1.822289",
    "https://www.hollywoodreporter.com/t/rss"
  ]
};

let activeCategory = "Sports";
const allArticles = {}; 
const categoryTabs = document.getElementById("categoryTabs");
const contentDiv   = document.getElementById("content");
const spinner      = document.getElementById("loadingSpinner");
const backToTopBtn = document.getElementById("backToTop");

// Create category buttons
Object.keys(categories).forEach(cat => {
  const btn = document.createElement("button");
  btn.textContent = cat;
  btn.onclick = () => { setActiveCategory(cat); };
  if (cat === activeCategory) btn.classList.add("active");
  categoryTabs.appendChild(btn);
});

// Back-to-top button logic
backToTopBtn.onclick = () => window.scrollTo({ top: 0, behavior: "smooth" });

// Debounce scroll for infinite scroll and back-to-top button visibility
let scrollTimeout = null;
window.addEventListener("scroll", () => {
  if (window.scrollY > 120) backToTopBtn.classList.add("show");
  else backToTopBtn.classList.remove("show");

  if (scrollTimeout) clearTimeout(scrollTimeout);
  scrollTimeout = setTimeout(checkInfiniteScroll, 100);
});

// Helpers
function toET(dateStr) {
  const d = new Date(dateStr);
  return new Date(d.getTime() - 4*60*60*1000);
}

function extractImage(item) {
  if(item.enclosure && item.enclosure.link) return item.enclosure.link;
  if(item.thumbnail) return item.thumbnail;
  if(item.content && /<img/i.test(item.content)){
    const tmp = document.createElement("div");
    tmp.innerHTML = item.content;
    const img = tmp.querySelector("img");
    if(img && img.src) return img.src;
  }
  if(item.description && /<img/i.test(item.description)){
    const tmp = document.createElement("div");
    tmp.innerHTML = item.description;
    const img = tmp.querySelector("img");
    if(img && img.src) return img.src;
  }
  return null;
}

async function fetchFeed(url) {
  const apiUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(url)}&api_key=${API_KEY}&count=50`;
  try {
    const res = await fetch(apiUrl);
    const data = await res.json();
    if(data.status !== "ok") return [];
    return data.items.map(i => ({...i, source: data.feed.title}));
  } catch(e) {
    console.error("Fetch error", url, e);
    return [];
  }
}

// Load Category: prepares feeds, starts fetch chain
async function loadCategory(cat) {
  spinner.style.display = "block";
  allArticles[cat] = { feeds: [], merged: [], shown: 0, fetching: false };
  categories[cat].forEach(url => {
    allArticles[cat].feeds.push({ url, items: [], loaded: false });
  });
  await fetchNextFeed(cat);
  spinner.style.display = "none";
  await renderBatch(cat);
}

// Fetch next feed in category lazily
async function fetchNextFeed(cat){
  const catState = allArticles[cat];
  const feed = catState.feeds.find(f => !f.loaded);
  if(!feed) return;
  const items = await fetchFeed(feed.url);
  feed.items = items.filter(a => {
    const img = extractImage(a);
    if(!img) return false;
    a.imgUrl = img;
    return true;
  });
  feed.loaded = true;
  mergeCategory(cat);
}

// Merge feeds, remove duplicates, and sort
function mergeCategory(cat){
  const catState = allArticles[cat];
  let combined = [];
  catState.feeds.forEach(f => combined = combined.concat(f.items));
  const seen = new Set();
  catState.merged = combined.filter(a => {
    if(seen.has(a.link)) return false;
    seen.add(a.link);
    return true;
  }).sort((a,b) => new Date(b.pubDate) - new Date(a.pubDate));
}

// Render next batch of cards for category with concurrency protections
async function renderBatch(cat){
  const state = allArticles[cat];
  if(!state) return;

  // If no more articles currently merged but some feeds remain unloaded, fetch next before rendering
  if(state.shown >= state.merged.length) {
    const remainingFeed = state.feeds.find(f => !f.loaded);
    if(remainingFeed) {
      if(state.fetching) return; // Prevent concurrent fetches
      state.fetching = true;
      spinner.style.display = "block";
      await fetchNextFeed(cat);
      spinner.style.display = "none";
      state.fetching = false;
      // Retry rendering batch after new feed merged
      await renderBatch(cat);
      return;
    }
  }

  const nextBatch = state.merged.slice(state.shown, state.shown + BATCH_SIZE);
  nextBatch.forEach(a => {
    const card = document.createElement("div");
    card.className = "card";

    const img = document.createElement("img");
    img.src = a.imgUrl || PLACEHOLDER;
    img.onerror = () => { img.src = PLACEHOLDER; };

    const info = document.createElement("div");
    info.className = "info";

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = a.title;
    title.onclick = () => window.open(a.link, "_blank");

    const summary = document.createElement("div");
    summary.className = "summary";
    summary.innerHTML = (a.description || '').replace(/<img[^>]*>/gi,'');

    const src = document.createElement("div");
    src.className = "source";
    src.textContent = a.source;

    const date = document.createElement("div");
    date.className = "date";
    date.textContent = toET(a.pubDate).toLocaleString();

    info.append(title, summary, src, date);
    card.append(img, info);
    contentDiv.appendChild(card);
  });
  state.shown += nextBatch.length;
}

// Infinite scroll trigger, only triggers if there are articles left or feeds unloaded
function checkInfiniteScroll() {
  const state = allArticles[activeCategory];
  if(!state) return;
  if(state.shown < state.merged.length || state.feeds.some(f => !f.loaded)) {
    if(window.innerHeight + window.scrollY >= document.body.offsetHeight - 200){
      renderBatch(activeCategory);
    }
  }
}

// Switch active category and render or load as needed
async function setActiveCategory(cat){
  activeCategory = cat;
  contentDiv.innerHTML = "";
  Array.from(categoryTabs.children).forEach(btn => {
    btn.classList.toggle("active", btn.textContent === cat);
  });
  if(!allArticles[cat]) {
    await loadCategory(cat);
  } else {
    await renderBatch(cat);
  }
}

// Initialization
(async () => {
  await loadCategory(activeCategory);
})();
</script>
</body>
</html>
