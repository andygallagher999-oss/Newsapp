<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Global Lens</title>
<style>
  body { font-family: Arial,sans-serif; margin:0; background:#f5f5f5; }
  header { background:#222; color:#fff; padding:10px; text-align:center; font-size:1.4em; }
  #categoryTabs { display:flex; overflow-x:auto; background:#333; }
  #categoryTabs button {
    flex:1; padding:10px; border:none; background:#333; color:#fff; font-size:1em;
    cursor:pointer; white-space:nowrap; outline:none;
  }
  #categoryTabs button.active { background:#555; }
  #content { padding:10px; max-width:900px; margin:auto; }
  .card {
    display:flex; background:#fff; margin-bottom:10px;
    border-radius:6px; overflow:hidden; box-shadow:0 2px 4px rgba(0,0,0,.1);
  }
  .card img {
    width:100px; height:100px; object-fit:cover; flex-shrink:0;
  }
  .info { padding:10px; flex:1; display:flex; flex-direction:column; }
  .title {
    font-weight:bold; margin-bottom:5px; cursor:pointer;
    display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden;
  }
  .summary {
    display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden;
    margin-bottom:5px; font-size:0.9em; color:#333;
  }
  .source { color:#666; font-size:0.85em; }
  .date { color:#999; font-size:0.8em; margin-bottom:6px; }
  #loadingSpinner { text-align:center; padding:15px; display:none; color:#555; }
  .end-message { 
    text-align:center; padding:20px; color:#666; font-style:italic; display:none;
  }
  #backToTop {
    position: fixed;
    bottom: 30px;
    right: 30px;
    z-index: 999;
    display: none;
    background: #333;
    color: #fff;
    border: none;
    padding: 13px;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(50,50,50,0.15);
    opacity: 0;
    transition: opacity 0.3s;
  }
  #backToTop.show {
    display: block;
    opacity: 1;
  }
  #backToTop:hover {
    background: #555;
  }
</style>
</head>
<body>
<header>Global Lens</header>

<div id="categoryTabs"></div>
<div id="content"></div>
<div id="loadingSpinner">Loading…</div>
<div class="end-message" id="endMessage">No more articles to load</div>
<button id="backToTop" title="Back to top">↑</button>

<script>
const API_KEY = "mfvxyevwnjlcnuwmiyprrivbbpyylyhwwzuezdaq";
const BATCH_SIZE = 8;
const PLACEHOLDER = "logo.png";

const categories = {
  Sports: [
    { url: "https://feeds.skysports.com/feeds/rss/football.xml", direct: true },
    { url: "https://feeds.bbci.co.uk/sport/rss.xml", direct: true },
    { url: "https://rss.cnn.com/rss/edition_sport.rss", direct: true },
    { url: "https://www.sportsnet.ca/feed/", direct: false },
    { url: "https://www.espn.com/espn/rss/news", direct: false }
  ],
  Business: [
    { url: "https://feeds.reuters.com/reuters/businessNews", direct: true },
    { url: "https://feeds.bbci.co.uk/news/business/rss.xml", direct: true },
    { url: "https://rss.cnn.com/rss/money_latest.rss", direct: true },
    { url: "https://www.marketwatch.com/rss/topstories", direct: false },
    { url: "https://www.investing.com/rss/news.rss", direct: false }
  ],
  News: [
    { url: "https://feeds.bbci.co.uk/news/rss.xml", direct: true },
    { url: "https://rss.cnn.com/rss/edition.rss", direct: true },
    { url: "https://feeds.reuters.com/reuters/topNews", direct: true },
    { url: "https://feeds.npr.org/1001/rss.xml", direct: true },
    { url: "https://feeds.nbcnews.com/nbcnews/public/news", direct: false }
  ],
  Entertainment: [
    { url: "https://feeds.eonline.com/eonline/news", direct: true },
    { url: "https://feeds.feedburner.com/people/headlines", direct: true },
    { url: "https://www.tmz.com/rss.xml", direct: false },
    { url: "https://www.usmagazine.com/feed/", direct: false },
    { url: "https://www.justjared.com/feed/", direct: false }
  ]
};

let activeCategory = "Sports";
const allArticles = {};
const imageCache = new Map(); // Cache for fetched images
const categoryTabs = document.getElementById("categoryTabs");
const contentDiv = document.getElementById("content");
const spinner = document.getElementById("loadingSpinner");
const backToTopBtn = document.getElementById("backToTop");
const endMessage = document.getElementById("endMessage");

// Create category buttons
Object.keys(categories).forEach(cat => {
  const btn = document.createElement("button");
  btn.textContent = cat;
  btn.onclick = () => { setActiveCategory(cat); };
  if (cat === activeCategory) btn.classList.add("active");
  categoryTabs.appendChild(btn);
});

// Back-to-top button logic
backToTopBtn.onclick = () => window.scrollTo({ top: 0, behavior: "smooth" });

// Debounce scroll for infinite scroll and back-to-top button visibility
let scrollTimeout = null;
window.addEventListener("scroll", () => {
  if (window.scrollY > 120) backToTopBtn.classList.add("show");
  else backToTopBtn.classList.remove("show");

  if (scrollTimeout) clearTimeout(scrollTimeout);
  scrollTimeout = setTimeout(checkInfiniteScroll, 100);
});

// Helpers
function toET(dateStr) {
  const d = new Date(dateStr);
  return new Date(d.getTime() - 4*60*60*1000);
}

async function extractImage(item, fetchFallback = true) {
  // Quick checks from RSS fields
  if (item.xmlImg) return item.xmlImg;
  if (item.enclosure && item.enclosure.link) return item.enclosure.link;
  if (item.thumbnail) return item.thumbnail;
  if (item['media:thumbnail'] && item['media:thumbnail'].url) return item['media:thumbnail'].url;

  // Parse content fields for <img> (prioritize largest/first featured)
  const contentFields = [item.content, item.description, item.summary, item['content:encoded']];
  for (const field of contentFields) {
    if (!field || !/<img/i.test(field)) continue;
    
    const tmp = document.createElement("div");
    tmp.innerHTML = field;
    const imgs = tmp.querySelectorAll("img");
    
    // Sort by size (largest first), skip tiny/tracking pixels, prefer featured
    let bestImg = null;
    let maxArea = 0;
    imgs.forEach(img => {
      if (img.src && !img.src.startsWith('data:image') && !img.src.includes('pixel') && !img.src.includes('spacer')) {
        const w = parseInt(img.width) || 200;
        const h = parseInt(img.height) || 200;
        const area = w * h;
        const isFeatured = img.alt?.toLowerCase().includes('featured') || img.className?.includes('hero');
        
        if ((isFeatured || area > maxArea) && w > 50 && h > 50) {
          bestImg = img.src;
          maxArea = area;
        }
      }
    });
    if (bestImg) return bestImg;
  }

  // Meta tags in content (og:image, twitter:image, etc.)
  for (const field of contentFields) {
    if (!field) continue;
    const matches = [
      ...field.matchAll(/property=["']og:image["']\s*content=["']([^"']+)/gi),
      ...field.matchAll(/name=["']twitter:image["']\s*content=["']([^"']+)/gi),
      ...field.matchAll(/<meta\s+property=["']og:image["']\s+content=["']([^"']+)/gi)
    ];
    if (matches.length > 0) return matches[0][1];
  }

  // Fallback: Fetch page head for meta images (async, cached, CORS-proxied)
  if (fetchFallback && item.link && !imageCache.has(item.link)) {
    try {
      // Using a free CORS proxy (alternative: use rss2json API as proxy)
      const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(item.link)}`;
      const res = await fetch(proxyUrl);
      const data = await res.json();
      
      const html = data.contents || '';
      const ogMatch = html.match(/<meta\s+property=["']og:image["']\s+content=["']([^"']+)/i);
      const twitterMatch = html.match(/<meta\s+name=["']twitter:image["']\s+content=["']([^"']+)/i);
      
      const fallbackImg = ogMatch?.[1] || twitterMatch?.[1];
      if (fallbackImg) {
        imageCache.set(item.link, fallbackImg);
        return fallbackImg;
      }
    } catch (e) {
      console.warn(`Fallback fetch failed for ${item.link}:`, e);
    }
  } else if (imageCache.has(item.link)) {
    return imageCache.get(item.link);
  }

  return null;
}

async function fetchFeed(feedObj) {
  if (feedObj.direct) {
    try {
      const response = await fetch(feedObj.url);
      const xmlText = await response.text();
      console.log(`Direct RSS fetch: ${feedObj.url}`, response.status);
      
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
      
      const parserError = xmlDoc.querySelector('parsererror');
      if (parserError) {
        console.warn(`XML parsing error for ${feedObj.url}:`, parserError.textContent);
        return [];
      }
      
      const items = Array.from(xmlDoc.querySelectorAll('item')).map(item => {
        const title = item.querySelector('title')?.textContent || '';
        const link = item.querySelector('link')?.textContent || '';
        const description = item.querySelector('description')?.textContent || '';
        const pubDate = item.querySelector('pubDate')?.textContent || '';
        const contentEncoded = item.querySelector('content\\:encoded')?.textContent || description;
        
        let xmlImg = null;
        const mediaContent = item.querySelector('media\\:content');
        if (mediaContent && mediaContent.getAttribute('medium') === 'image') {
          xmlImg = mediaContent.getAttribute('url') || mediaContent.textContent;
        }
        if (!xmlImg && item.querySelector('enclosure[type*="image"]')) {
          xmlImg = item.querySelector('enclosure').getAttribute('url');
        }
        
        const channelTitle = xmlDoc.querySelector('channel > title')?.textContent || 'Unknown';
        
        return {
          title: title.trim(),
          link: link.trim(),
          description: description,
          content: contentEncoded,
          pubDate: pubDate,
          source: channelTitle,
          xmlImg: xmlImg
        };
      });
      
      console.log(`Direct RSS parsed ${items.length} items from ${feedObj.url}`);
      return items;
    } catch (error) {
      console.error(`Direct RSS fetch error for ${feedObj.url}:`, error);
      return [];
    }
  } else {
    const apiUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(feedObj.url)}&api_key=${API_KEY}&count=50`;
    try {
      const res = await fetch(apiUrl);
      const data = await res.json();
      console.log(`RSS2JSON fetch: ${feedObj.url}`, data);
      if (data.status !== "ok") {
        console.warn(`Failed to fetch ${feedObj.url}:`, data.message || data.status);
        return [];
      }
      return data.items.map(i => ({ ...i, source: data.feed.title }));
    } catch (e) {
      console.error("RSS2JSON fetch error", feedObj.url, e);
      return [];
    }
  }
}

function initCategoryState(cat) {
  allArticles[cat] = { 
    feeds: [], 
    merged: [], 
    shown: 0, 
    fetching: false,
    allFeedsLoaded: false,
    hasMoreContent: true
  };
  categories[cat].forEach(feedObj => {
    allArticles[cat].feeds.push({ 
      url: feedObj.url, 
      direct: feedObj.direct, 
      items: [], 
      loaded: false 
    });
  });
}

async function loadCategory(cat) {
  spinner.style.display = "block";
  endMessage.style.display = "none";
  
  initCategoryState(cat);
  
  await fetchNextBatch(cat);
  
  spinner.style.display = "none";
  await renderBatch(cat);
  updateEndMessage(cat);
}

async function fetchNextBatch(cat) {
  const catState = allArticles[cat];
  const unloadedFeeds = catState.feeds.filter(f => !f.loaded);
  
  if (unloadedFeeds.length === 0) {
    catState.allFeedsLoaded = true;
    return;
  }
  
  const feedsToLoad = unloadedFeeds.slice(0, 2);
  const promises = feedsToLoad.map(async feed => {
    const feedObj = { url: feed.url, direct: feed.direct };
    const items = await fetchFeed(feedObj);
    
    const processedItems = await Promise.all(items.map(async a => {
      const img = await extractImage(a, true);
      a.imgUrl = img || PLACEHOLDER;
      return a;
    }));
    
    feed.items = processedItems;
    console.log(`Loaded ${feed.items.length} items from ${feed.url} (direct: ${feed.direct}, images: ${feed.items.filter(i => i.imgUrl !== PLACEHOLDER).length})`);
    feed.loaded = true;
  });
  
  await Promise.all(promises);
  mergeCategory(cat);
  
  console.log(`Category ${cat}: Total merged articles: ${allArticles[cat].merged.length}`);
}

function mergeCategory(cat) {
  const catState = allArticles[cat];
  let combined = [];
  catState.feeds.forEach(f => combined = combined.concat(f.items));
  const seen = new Set();
  catState.merged = combined.filter(a => {
    if (seen.has(a.link)) return false;
    seen.add(a.link);
    return true;
  }).sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate));
}

async function renderBatch(cat) {
  const state = allArticles[cat];
  if (!state || state.fetching) return;

  if (state.shown >= state.merged.length && !state.allFeedsLoaded) {
    state.fetching = true;
    spinner.style.display = "block";
    await fetchNextBatch(cat);
    spinner.style.display = "none";
    state.fetching = false;
  }

  const hasMoreToShow = state.shown < state.merged.length;
  const hasUnloadedFeeds = !state.allFeedsLoaded;
  state.hasMoreContent = hasMoreToShow || hasUnloadedFeeds;

  if (!hasMoreToShow) {
    updateEndMessage(cat);
    return;
  }

  const nextBatch = state.merged.slice(state.shown, state.shown + BATCH_SIZE);
  nextBatch.forEach(a => {
    const card = document.createElement("div");
    card.className = "card";

    const img = document.createElement("img");
    img.src = a.imgUrl || PLACEHOLDER;
    img.alt = a.title;
    img.loading = "lazy";
    img.onerror = () => {
      console.warn(`Image failed: ${a.imgUrl}`);
      img.src = PLACEHOLDER;
      // Optional retry with resized image
      // setTimeout(() => { if (img.src === PLACEHOLDER) img.src = a.imgUrl + '?w=100&h=100'; }, 1000);
    };

    const info = document.createElement("div");
    info.className = "info";

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = a.title;
    title.onclick = () => window.open(a.link, "_blank");

    const summary = document.createElement("div");
    summary.className = "summary";
    summary.innerHTML = (a.description || '').replace(/<img[^>]*>/gi, '');

    const src = document.createElement("div");
    src.className = "source";
    src.textContent = a.source;

    const date = document.createElement("div");
    date.className = "date";
    date.textContent = toET(a.pubDate).toLocaleString();

    info.append(title, summary, src, date);
    card.append(img, info);
    contentDiv.appendChild(card);
  });
  
  state.shown += nextBatch.length;
  updateEndMessage(cat);
}

function updateEndMessage(cat) {
  const state = allArticles[cat];
  if (!state) return;
  
  if (!state.hasMoreContent && state.allFeedsLoaded) {
    endMessage.style.display = "block";
  } else {
    endMessage.style.display = "none";
  }
}

function checkInfiniteScroll() {
  const state = allArticles[activeCategory];
  if (!state || state.fetching || !state.hasMoreContent) return;
  
  if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 300) {
    renderBatch(activeCategory);
  }
}

async function setActiveCategory(cat) {
  if (activeCategory === cat) return;
  
  activeCategory = cat;
  contentDiv.innerHTML = "";
  endMessage.style.display = "none";
  
  Array.from(categoryTabs.children).forEach(btn => {
    btn.classList.toggle("active", btn.textContent === cat);
  });
  
  if (!allArticles[cat]) {
    await loadCategory(cat);
  } else {
    allArticles[cat].shown = 0;
    await renderBatch(cat);
    if (allArticles[cat].hasMoreContent) {
      await renderBatch(cat);
    }
  }
}

(async () => {
  await loadCategory(activeCategory);
})();
</script>
</body>
</html>
